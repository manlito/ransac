{"version":3,"sources":["ransac.js","src/ransac.js"],"names":[],"mappings":"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","file":"ransac.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ransac = factory()\n}(this, function () { 'use strict';\n\n  class Ransac {\n\n    constructor(problem) {\n      this.problem = problem;\n    }\n\n    // Get a randome sample from problem of sampleSize\n    sample(sampleSize) {\n      var sample = [];\n      var currentSample = 0;\n      while (currentSample < sampleSize) {\n        var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n        // Avoid adding duplicated entries\n        if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n          sample.push(this.problem.data[randomIndex]);\n          ++currentSample;\n        }\n      }\n      return sample;\n    }\n\n    // Tell how good a model is, for all points. By default,\n    // it uses sum of squared differences\n    modelError(model) {\n      var problem = this.problem;\n      var ssd = problem.data.reduce(function (a, b) {\n        var error = problem.fit(model, b);\n        return a + Math.pow(error, 2);\n      }, 0);\n      return ssd;\n    }\n\n    // Tell which elements in data are inliers\n    classifyInliers(model, sample, options) {\n      var inliers = [];\n      var outliers = [];\n      var problem = this.problem;\n      problem.data.forEach(function (point) {\n        // Exclude inliers\n        if (sample.indexOf(point) === -1) {\n          if (problem.fit(model, point) <= options.threshold) {\n            inliers.push(point);\n          } else {\n            outliers.push(point);\n          }\n        }\n      });\n\n      return {\n        inliers: inliers,\n        outliers: outliers\n      };\n    }\n\n    // Actually perform RANSAC model fitting\n    estimate(options) {\n      var iteration = 0;\n\n      // When iterating, we keep track of the best model so far\n      var bestSolution = {\n        error: Infinity,\n        model: {},\n        inliers: [],\n        outliers: [],\n        status: 'Failed'\n      };\n\n      while (iteration < options.maxIterations) {\n        // Get a Sample. Only indexes are returned\n        var sample = this.sample(options.sampleSize);\n\n        // Estimate a model from the sample\n        var model = this.problem.model(sample);\n\n        // Get the inlier set\n        var pointGroups = this.classifyInliers(model, sample, options);\n        var inliers = pointGroups.inliers;\n        var outliers = pointGroups.outliers;\n\n        var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n        if (inliersRatio >= options.inliersRatio) {\n          var candidateModel = model;\n          if (options.improveModelWithConcensusSet) {\n            // Found a good model. Now fit all inliers and sampled\n            candidateModel = this.problem.model(inliers.concat(sample));\n          }\n          var candidateError = this.modelError(candidateModel);\n          if (candidateError < bestSolution.error) {\n            bestSolution = {\n              inliers: inliers,\n              outliers: outliers,\n              model: candidateModel,\n              error: candidateError,\n              status: 'Success'\n            };\n          }\n        }\n\n        ++iteration;\n      }\n\n      return bestSolution;\n    }\n  }\n\n  var ransac = Ransac;\n\n  return ransac;\n\n}));\n","class Ransac {\n\n  constructor(problem) {\n    this.problem = problem;\n  }\n\n  // Get a randome sample from problem of sampleSize\n  sample(sampleSize) {\n    var sample = [];\n    var currentSample = 0;\n    while (currentSample < sampleSize) {\n      var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n      // Avoid adding duplicated entries\n      if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n        sample.push(this.problem.data[randomIndex]);\n        ++currentSample;\n      }\n    }\n    return sample;\n  }\n\n  // Tell how good a model is, for all points. By default,\n  // it uses sum of squared differences\n  modelError(model) {\n    var problem = this.problem;\n    var ssd = problem.data.reduce(function (a, b) {\n      var error = problem.fit(model, b);\n      return a + Math.pow(error, 2);\n    }, 0);\n    return ssd;\n  }\n\n  // Tell which elements in data are inliers\n  classifyInliers(model, sample, options) {\n    var inliers = [];\n    var outliers = [];\n    var problem = this.problem;\n    problem.data.forEach(function (point) {\n      // Exclude inliers\n      if (sample.indexOf(point) === -1) {\n        if (problem.fit(model, point) <= options.threshold) {\n          inliers.push(point);\n        } else {\n          outliers.push(point);\n        }\n      }\n    });\n\n    return {\n      inliers: inliers,\n      outliers: outliers\n    };\n  }\n\n  // Actually perform RANSAC model fitting\n  estimate(options) {\n    var iteration = 0;\n\n    // When iterating, we keep track of the best model so far\n    var bestSolution = {\n      error: Infinity,\n      model: {},\n      inliers: [],\n      outliers: [],\n      status: 'Failed'\n    };\n\n    while (iteration < options.maxIterations) {\n      // Get a Sample. Only indexes are returned\n      var sample = this.sample(options.sampleSize);\n\n      // Estimate a model from the sample\n      var model = this.problem.model(sample);\n\n      // Get the inlier set\n      var pointGroups = this.classifyInliers(model, sample, options);\n      var inliers = pointGroups.inliers;\n      var outliers = pointGroups.outliers;\n\n      var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n      if (inliersRatio >= options.inliersRatio) {\n        var candidateModel = model;\n        if (options.improveModelWithConcensusSet) {\n          // Found a good model. Now fit all inliers and sampled\n          candidateModel = this.problem.model(inliers.concat(sample));\n        }\n        var candidateError = this.modelError(candidateModel);\n        if (candidateError < bestSolution.error) {\n          bestSolution = {\n            inliers: inliers,\n            outliers: outliers,\n            model: candidateModel,\n            error: candidateError,\n            status: 'Success'\n          };\n        }\n      }\n\n      ++iteration;\n    }\n\n    return bestSolution;\n  }\n}\n\nexport default Ransac;\n"],"sourceRoot":"/source/"}