{"version":3,"sources":["ransac.min.js","/source/ransac.js","/source/src/ransac.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","Ransac","this","problem","value","sample","sampleSize","currentSample","randomIndex","Math","floor","random","data","indexOf","push","model","ssd","reduce","a","b","error","fit","pow","options","inliers","outliers","forEach","point","threshold","maxIterations","inliersRatio","improveModelWithConcensusSet","iteration","bestSolution","Infinity","status","pointGroups","classifyInliers","parseFloat","candidateModel","concat","candidateError","modelError","ransac"],"mappings":"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","file":"ransac.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ransac = factory()\n}(this, function () { 'use strict';\n\n  class Ransac {\n\n    constructor(problem) {\n      this.problem = problem;\n    }\n\n    // Get a randome sample from problem of sampleSize\n    sample(sampleSize) {\n      var sample = [];\n      var currentSample = 0;\n      while (currentSample < sampleSize) {\n        var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n        // Avoid adding duplicated entries\n        if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n          sample.push(this.problem.data[randomIndex]);\n          ++currentSample;\n        }\n      }\n      return sample;\n    }\n\n    // Tell how good a model is, for all points. By default,\n    // it uses sum of squared differences\n    modelError(model) {\n      var problem = this.problem;\n      var ssd = problem.data.reduce((a, b) => {\n        var error = problem.fit(model, b);\n        return a + Math.pow(error, 2);\n      }, 0);\n      return ssd;\n    }\n\n    // Tell which elements in data are inliers\n    classifyInliers(model, sample, options) {\n      var inliers = [];\n      var outliers = [];\n      var problem = this.problem;\n      problem.data.forEach((point) => {\n        // Exclude inliers\n        if (sample.indexOf(point) === -1) {\n          if (problem.fit(model, point) <= options.threshold) {\n            inliers.push(point);\n          } else {\n            outliers.push(point);\n          }\n        }\n      });\n\n      return {\n        inliers: inliers,\n        outliers: outliers\n      };\n    }\n\n    // Actually perform RANSAC model fitting\n    estimate(options) {\n\n      // Default options\n      options = options || {};\n      options.sampleSize = options.sampleSize || 2;\n      options.threshold = options.threshold || 0.1;\n      options.maxIterations = options.maxIterations || 30;\n      options.inliersRatio = options.inliersRatio || 0.7;\n      if (typeof options.improveModelWithConcensusSet === 'undefined') {\n        options.improveModelWithConcensusSet = true;\n      }\n\n      var iteration = 0;\n\n      // When iterating, we keep track of the best model so far\n      var bestSolution = {\n        error: Infinity,\n        model: {},\n        inliers: [],\n        outliers: [],\n        status: 'Failed'\n      };\n\n      while (iteration < options.maxIterations) {\n        // Get a Sample. Only indexes are returned\n        var sample = this.sample(options.sampleSize);\n\n        // Estimate a model from the sample\n        var model = this.problem.model(sample);\n\n        // Get the inlier set\n        var pointGroups = this.classifyInliers(model, sample, options);\n        var inliers = pointGroups.inliers;\n        var outliers = pointGroups.outliers;\n\n        var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n        if (inliersRatio >= options.inliersRatio) {\n          var candidateModel = model;\n          if (options.improveModelWithConcensusSet) {\n            // Found a good model. Now fit all inliers and sampled\n            candidateModel = this.problem.model(inliers.concat(sample));\n          }\n          var candidateError = this.modelError(candidateModel);\n          if (candidateError < bestSolution.error) {\n            bestSolution = {\n              inliers: inliers,\n              outliers: outliers,\n              model: candidateModel,\n              error: candidateError,\n              status: 'Success'\n            };\n          }\n        }\n\n        ++iteration;\n      }\n\n      return bestSolution;\n    }\n  }\n\n  var ransac = Ransac;\n\n  return ransac;\n\n}));\n","class Ransac {\n\n  constructor(problem) {\n    this.problem = problem;\n  }\n\n  // Get a randome sample from problem of sampleSize\n  sample(sampleSize) {\n    var sample = [];\n    var currentSample = 0;\n    while (currentSample < sampleSize) {\n      var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n      // Avoid adding duplicated entries\n      if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n        sample.push(this.problem.data[randomIndex]);\n        ++currentSample;\n      }\n    }\n    return sample;\n  }\n\n  // Tell how good a model is, for all points. By default,\n  // it uses sum of squared differences\n  modelError(model) {\n    var problem = this.problem;\n    var ssd = problem.data.reduce((a, b) => {\n      var error = problem.fit(model, b);\n      return a + Math.pow(error, 2);\n    }, 0);\n    return ssd;\n  }\n\n  // Tell which elements in data are inliers\n  classifyInliers(model, sample, options) {\n    var inliers = [];\n    var outliers = [];\n    var problem = this.problem;\n    problem.data.forEach((point) => {\n      // Exclude inliers\n      if (sample.indexOf(point) === -1) {\n        if (problem.fit(model, point) <= options.threshold) {\n          inliers.push(point);\n        } else {\n          outliers.push(point);\n        }\n      }\n    });\n\n    return {\n      inliers: inliers,\n      outliers: outliers\n    };\n  }\n\n  // Actually perform RANSAC model fitting\n  estimate(options) {\n\n    // Default options\n    options = options || {};\n    options.sampleSize = options.sampleSize || 2;\n    options.threshold = options.threshold || 0.1;\n    options.maxIterations = options.maxIterations || 30;\n    options.inliersRatio = options.inliersRatio || 0.7;\n    if (typeof options.improveModelWithConcensusSet === 'undefined') {\n      options.improveModelWithConcensusSet = true;\n    }\n\n    var iteration = 0;\n\n    // When iterating, we keep track of the best model so far\n    var bestSolution = {\n      error: Infinity,\n      model: {},\n      inliers: [],\n      outliers: [],\n      status: 'Failed'\n    };\n\n    while (iteration < options.maxIterations) {\n      // Get a Sample. Only indexes are returned\n      var sample = this.sample(options.sampleSize);\n\n      // Estimate a model from the sample\n      var model = this.problem.model(sample);\n\n      // Get the inlier set\n      var pointGroups = this.classifyInliers(model, sample, options);\n      var inliers = pointGroups.inliers;\n      var outliers = pointGroups.outliers;\n\n      var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n      if (inliersRatio >= options.inliersRatio) {\n        var candidateModel = model;\n        if (options.improveModelWithConcensusSet) {\n          // Found a good model. Now fit all inliers and sampled\n          candidateModel = this.problem.model(inliers.concat(sample));\n        }\n        var candidateError = this.modelError(candidateModel);\n        if (candidateError < bestSolution.error) {\n          bestSolution = {\n            inliers: inliers,\n            outliers: outliers,\n            model: candidateModel,\n            error: candidateError,\n            status: 'Success'\n          };\n        }\n      }\n\n      ++iteration;\n    }\n\n    return bestSolution;\n  }\n}\n\nexport default Ransac;\n"],"sourceRoot":"/source/"}