{"version":3,"sources":["ransac.min.js","/source/ransac.js","/source/src/ransac.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","define","amd","Ransac","this","problem","value","sample","sampleSize","currentSample","randomIndex","Math","floor","random","data","indexOf","push","model","ssd","reduce","a","b","error","fit","pow","options","inliers","outliers","forEach","point","threshold","iteration","bestSolution","Infinity","status","maxIterations","pointGroups","classifyInliers","inliersRatio","parseFloat","candidateModel","improveModelWithConcensusSet","concat","candidateError","modelError","ransac"],"mappings":"AAEA,QAASA,iBAAgBC,EAAUC,GAAe,KAAMD,YAAoBC,IAAgB,KAAM,IAAIC,WAAU,qCAFhH,GAAIC,cAAe,WAAe,QAASC,GAAiBC,EAAQC,GAAS,IAAK,GAAIC,GAAI,EAAGA,EAAID,EAAME,OAAQD,IAAK,CAAE,GAAIE,GAAaH,EAAMC,EAAIE,GAAWC,WAAaD,EAAWC,aAAc,EAAOD,EAAWE,cAAe,EAAU,SAAWF,KAAYA,EAAWG,UAAW,GAAMC,OAAOC,eAAeT,EAAQI,EAAWM,IAAKN,IAAiB,MAAO,UAAUR,EAAae,EAAYC,GAAiJ,MAA9HD,IAAYZ,EAAiBH,EAAYiB,UAAWF,GAAiBC,GAAab,EAAiBH,EAAagB,GAAqBhB,OCAjiB,SAAWkB,EAAQC,GACE,gBAAZC,UAA0C,mBAAXC,QAAyBA,OAAOD,QAAUD,IAC9D,kBAAXG,SAAyBA,OAAOC,IAAMD,OAAOH,GACpDD,EAAOM,OAASL,KAChBM,KAAM,WAAc,YDKpB,IETID,GAAA,WAEO,QAFPA,GAEQE,GFSR5B,gBAAgB2B,KEXhBD,GAGFC,KAAKC,QAAUA,EFyHf,MA1GAxB,cElBEsB,IFmBAV,IAAK,SACLa,MEbE,QAAAC,GAACC,GAGL,IAFA,GAAID,MACAE,EAAgB,EACGD,EAAhBC,GAA4B,CACjC,GAAIC,GAAcC,KAAKC,MAAMD,KAAKE,SAAWT,KAAKC,QAAQS,KAAK5B,OAER,MAAnDqB,EAAOQ,QAAQX,KAAKC,QAAQS,KAAKJ,MACnCH,EAAOS,KAAKZ,KAAKC,QAAQS,KAAKJ,MAC5BD,GAGN,MAAOF,MFmBLd,IAAK,aACLa,MEfM,SAACW,GACT,GAAIZ,GAAUD,KAAKC,QACfa,EAAMb,EAAQS,KAAKK,OAAO,SAAUC,EAAGC,GACzC,GAAIC,GAAQjB,EAAQkB,IAAIN,EAAOI,EAC/B,OAAOD,GAAIT,KAAKa,IAAIF,EAAO,IAC1B,EACH,OAAOJ,MFoBLzB,IAAK,kBACLa,MEjBW,SAACW,EAAOV,EAAQkB,GAC7B,GAAIC,MACAC,KACAtB,EAAUD,KAAKC,OAYnB,OAXAA,GAAQS,KAAKc,QAAQ,SAAUC,GAEC,KAA1BtB,EAAOQ,QAAQc,KACbxB,EAAQkB,IAAIN,EAAOY,IAAUJ,EAAQK,UACvCJ,EAAQV,KAAKa,GAEbF,EAASX,KAAKa,OAMlBH,QAASA,EACTC,SAAUA,MFuBVlC,IAAK,WACLa,MEnBI,SAACmB,GAYP,IAXA,GAAIM,GAAY,EAGZC,GACFV,MAAOW,EAAAA,EACPhB,SACAS,WACAC,YACAO,OAAQ,UAGHH,EAAYN,EAAQU,eAAe,CAExC,GAAI5B,GAASH,KAAKG,OAAOkB,EAAQjB,YAG7BS,EAAQb,KAAKC,QAAQY,MAAMV,GAG3B6B,EAAchC,KAAKiC,gBAAgBpB,EAAOV,EAAQkB,GAClDC,EAAUU,EAAYV,QACtBC,EAAWS,EAAYT,SAEvBW,EAAeZ,EAAQxC,OAASqD,WAAWnC,KAAKC,QAAQS,KAAK5B,OACjE,IAAIoD,GAAgBb,EAAQa,aAAc,CACxC,GAAIE,GAAiBvB,CACjBQ,GAAQgB,+BAEVD,EAAiBpC,KAAKC,QAAQY,MAAMS,EAAQgB,OAAOnC,IAErD,IAAIoC,GAAiBvC,KAAKwC,WAAWJ,EACjCG,GAAiBX,EAAaV,QAChCU,GACEN,QAASA,EACTC,SAAUA,EACVV,MAAOuB,EACPlB,MAAOqB,EACPT,OAAQ,cAKZH,EAGJ,MAAOC,OArGL7B,KAAN0C,EAAA1C,CDiHE,OAAO0C","file":"ransac.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n  typeof define === 'function' && define.amd ? define(factory) :\n  global.Ransac = factory()\n}(this, function () { 'use strict';\n\n  class Ransac {\n\n    constructor(problem) {\n      this.problem = problem;\n    }\n\n    // Get a randome sample from problem of sampleSize\n    sample(sampleSize) {\n      var sample = [];\n      var currentSample = 0;\n      while (currentSample < sampleSize) {\n        var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n        // Avoid adding duplicated entries\n        if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n          sample.push(this.problem.data[randomIndex]);\n          ++currentSample;\n        }\n      }\n      return sample;\n    }\n\n    // Tell how good a model is, for all points. By default,\n    // it uses sum of squared differences\n    modelError(model) {\n      var problem = this.problem;\n      var ssd = problem.data.reduce(function (a, b) {\n        var error = problem.fit(model, b);\n        return a + Math.pow(error, 2);\n      }, 0);\n      return ssd;\n    }\n\n    // Tell which elements in data are inliers\n    classifyInliers(model, sample, options) {\n      var inliers = [];\n      var outliers = [];\n      var problem = this.problem;\n      problem.data.forEach(function (point) {\n        // Exclude inliers\n        if (sample.indexOf(point) === -1) {\n          if (problem.fit(model, point) <= options.threshold) {\n            inliers.push(point);\n          } else {\n            outliers.push(point);\n          }\n        }\n      });\n\n      return {\n        inliers: inliers,\n        outliers: outliers\n      };\n    }\n\n    // Actually perform RANSAC model fitting\n    estimate(options) {\n      var iteration = 0;\n\n      // When iterating, we keep track of the best model so far\n      var bestSolution = {\n        error: Infinity,\n        model: {},\n        inliers: [],\n        outliers: [],\n        status: 'Failed'\n      };\n\n      while (iteration < options.maxIterations) {\n        // Get a Sample. Only indexes are returned\n        var sample = this.sample(options.sampleSize);\n\n        // Estimate a model from the sample\n        var model = this.problem.model(sample);\n\n        // Get the inlier set\n        var pointGroups = this.classifyInliers(model, sample, options);\n        var inliers = pointGroups.inliers;\n        var outliers = pointGroups.outliers;\n\n        var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n        if (inliersRatio >= options.inliersRatio) {\n          var candidateModel = model;\n          if (options.improveModelWithConcensusSet) {\n            // Found a good model. Now fit all inliers and sampled\n            candidateModel = this.problem.model(inliers.concat(sample));\n          }\n          var candidateError = this.modelError(candidateModel);\n          if (candidateError < bestSolution.error) {\n            bestSolution = {\n              inliers: inliers,\n              outliers: outliers,\n              model: candidateModel,\n              error: candidateError,\n              status: 'Success'\n            };\n          }\n        }\n\n        ++iteration;\n      }\n\n      return bestSolution;\n    }\n  }\n\n  var ransac = Ransac;\n\n  return ransac;\n\n}));\n","class Ransac {\n\n  constructor(problem) {\n    this.problem = problem;\n  }\n\n  // Get a randome sample from problem of sampleSize\n  sample(sampleSize) {\n    var sample = [];\n    var currentSample = 0;\n    while (currentSample < sampleSize) {\n      var randomIndex = Math.floor(Math.random() * this.problem.data.length);\n      // Avoid adding duplicated entries\n      if (sample.indexOf(this.problem.data[randomIndex]) === -1) {\n        sample.push(this.problem.data[randomIndex]);\n        ++currentSample;\n      }\n    }\n    return sample;\n  }\n\n  // Tell how good a model is, for all points. By default,\n  // it uses sum of squared differences\n  modelError(model) {\n    var problem = this.problem;\n    var ssd = problem.data.reduce(function (a, b) {\n      var error = problem.fit(model, b);\n      return a + Math.pow(error, 2);\n    }, 0);\n    return ssd;\n  }\n\n  // Tell which elements in data are inliers\n  classifyInliers(model, sample, options) {\n    var inliers = [];\n    var outliers = [];\n    var problem = this.problem;\n    problem.data.forEach(function (point) {\n      // Exclude inliers\n      if (sample.indexOf(point) === -1) {\n        if (problem.fit(model, point) <= options.threshold) {\n          inliers.push(point);\n        } else {\n          outliers.push(point);\n        }\n      }\n    });\n\n    return {\n      inliers: inliers,\n      outliers: outliers\n    };\n  }\n\n  // Actually perform RANSAC model fitting\n  estimate(options) {\n    var iteration = 0;\n\n    // When iterating, we keep track of the best model so far\n    var bestSolution = {\n      error: Infinity,\n      model: {},\n      inliers: [],\n      outliers: [],\n      status: 'Failed'\n    };\n\n    while (iteration < options.maxIterations) {\n      // Get a Sample. Only indexes are returned\n      var sample = this.sample(options.sampleSize);\n\n      // Estimate a model from the sample\n      var model = this.problem.model(sample);\n\n      // Get the inlier set\n      var pointGroups = this.classifyInliers(model, sample, options);\n      var inliers = pointGroups.inliers;\n      var outliers = pointGroups.outliers;\n\n      var inliersRatio = inliers.length / parseFloat(this.problem.data.length);\n      if (inliersRatio >= options.inliersRatio) {\n        var candidateModel = model;\n        if (options.improveModelWithConcensusSet) {\n          // Found a good model. Now fit all inliers and sampled\n          candidateModel = this.problem.model(inliers.concat(sample));\n        }\n        var candidateError = this.modelError(candidateModel);\n        if (candidateError < bestSolution.error) {\n          bestSolution = {\n            inliers: inliers,\n            outliers: outliers,\n            model: candidateModel,\n            error: candidateError,\n            status: 'Success'\n          };\n        }\n      }\n\n      ++iteration;\n    }\n\n    return bestSolution;\n  }\n}\n\nexport default Ransac;\n"],"sourceRoot":"/source/"}